require 'rubygems'
require 'bundler/setup'
require 'nokogiri'
require 'sass'

require 'thread'
require 'io/console'
require 'yaml'
require 'pp'

ThreadCount = 8
SCSSToolsLocation = 'compiled/scss/_falafel.scss'
STDOUT.echo = false

# Get starting time so we can calculate how long the task took.
starting_time = Time.now

# When finished, print the running time and make sure echo is turned on again.
at_exit do |success|
  print "\n"
  puts Time.at(Time.now - starting_time)
           .utc
           .strftime("Running time: \033[36m%H:%M:%S\033[0m")

  STDOUT.echo = true
end

def task_with_modes name, params: [], needs: []
  task name, (params << :mode) => needs do |task_obj, args|
    @mode = args[:mode]
    yield task_obj, args if block_given?
  end
end

task_with_modes :default, needs: [:noicons, :icons]

task_with_modes :noicons, needs: [:init, :fonts, :graphics, :scss, :css, :docs]

task_with_modes :init do
  puts "Initializing directories"

  mkdir_p [
            'compiled/icons',
            'compiled/scss',
            'compiled/css',
            'compiled/graphics',
            'compiled/fonts'
          ],
          verbose: false
end

task_with_modes :fonts, needs: [:init] do
  # TODO: Something is screwy with how fonts are being copied and removed
  copy_and_clean :fonts
end

task_with_modes :graphics, needs: [:init] do
  copy_and_clean :graphics
end

task_with_modes :scss, needs: [:init] do
  puts "Creating scss files"

  overwrite(
    SCSSToolsLocation,
    dynamic_scss + tools_scss_list.map { |path| File.new(path).read }
                                 .join("\n")
  )

  cleanup(:scss, SCSSToolsLocation)
end

task_with_modes :css, needs: [:init, :scss] do
  edited = []

  get_config['scss_rules_order'].each do |name, source_paths|
    puts "Compiling #{name}.css"

    new_path = "compiled/css/#{name}.css"
    edited << new_path

    scss = dynamic_scss +
           tools_scss_list.map { |path| "\n@import '#{path}';" }.join +
           Rake::FileList.new(*source_paths)
                         .map { |path| "\n@import '#{path}';" }
                         .join

    options = {
                syntax:     :scss,
                style:      :compressed,
                cache:      false,
                load_paths: [File.dirname(__FILE__)]
              }

    overwrite(
      new_path,
      Sass::Engine.new(scss, options).render
    )
  end

  cleanup(:css, *edited)
end

task_with_modes :icons, needs: [:init] do
  colors  = get_config['colors']
  message = 'Rendering icons'

  start_loading_message message

  edited = threaded_map(
                         Rake::FileList.new('icons/source/**/*.svg'),
                         'edited'
                       ) do |icon_array, thread_id|

             Thread.current['edited'] = []

             icon_array.each do |source_icon_path|
               svg = Nokogiri::XML(File.new(source_icon_path))

               svg.xpath('//comment()').remove

               colors.each do |color_name, color_data|

                 # Edit each SVG to include the proper color and remove comments

                 svg.xpath('//*[@fill] | //*[@stroke]').each do |element|
                   element['fill']   = color_data['color'] if element['fill']
                   element['stroke'] = color_data['color'] if element['stroke']
                 end

                 # Save the new SVG

                 new_file_path = 'compiled/icons/' +
                                 File.basename(source_icon_path, '.svg')
                                     .gsub(/-/, '_') +
                                 "__#{color_name}.svg"

                 if Thread.current['edited'].include?(new_file_path)
                   raise "duplicate icon at #{new_file_path}"
                 else
                   Thread.current['edited'] << new_file_path
                 end

                 if thread_id.zero?
                   loading_message(
                     message,
                     Thread.current['edited'].size.to_f /
                       (icon_array.size.to_f * colors.size.to_f)
                   )
                 end

                 overwrite(new_file_path, svg.to_s)
               end
             end
           end

  finish_loading_message message

  puts "Copying license files"
  overwrite(
    'compiled/icons/licenses.txt',
    Rake::FileList.new('icons/source/**/license.txt')
                  .map { |path| File.read(path) }
                  .join(("\n" * 3) + ("#" * 80) + ("\n" * 3))
  )

  cleanup(:icons, *edited)
end

task_with_modes :docs, needs: [:init] do
  puts "One day we will have docs to compile"
end

####################
## HELPER METHODS ##
####################

# Map across an array using threads to divide the work.
def threaded_map(items, key = nil)
  items.each_slice(items.size / ThreadCount)
       .map.with_index do |item_section, thread_id|
         Thread.new { yield item_section, thread_id }
       end
       .inject([]) do |memo, thread|
         if key
           thread.join
           memo.concat(thread[key])
         else
           memo << thread
         end
       end
end

def loading_message(message, fraction)
  print "\r#{message}: \033[36m" +
        sprintf("%5.1f", [1, fraction].min * 100) +
        "%\033[0m"
end

def cleanup(location, *edited)
  puts 'Checking for old files'

  leftovers = Rake::FileList.new("compiled/#{location}/**/*") - edited

  if leftovers.empty?
    puts 'No old files to delete'
  else
    slice_size = 100
    message    = 'Deleting old files'

    start_loading_message message

    leftovers.each_slice(slice_size).with_index do |section, index|
      %x( rm -r #{section.join(' ')} )

      loading_message(
        message,
        (index.to_f * slice_size.to_f) / leftovers.size.to_f
      )
    end

    finish_loading_message message
  end
end

def start_loading_message(message)
  print message + ': ...'
end

def finish_loading_message(message)
  loading_message message, 1
  print "\n"
end

def get_config
  @config ||= YAML.load(File.read('config_default.yaml'))
                  .tap do |default_config|
                    config_merge! default_config, 'config_before.yaml'

                    if @mode == 'dev'
                      config_merge! default_config, 'config_development.yaml'
                    end

                    config_merge! default_config, 'config_after.yaml'
                  end
end

def config_merge!(old_config, new_config_name)
  if File.exist? new_config_name
    old_config.deep_merge!(
      YAML.load(
        File.read(new_config_name)
      )
    )
  end
end

def overwrite(path, content)
  File.open(path, 'w+') { |file| file.write(content) }
end

def color_by_name(name)
  get_config['colors'][name]['color']
end

def dynamic_scss
  color_vars = get_config['colors'].inject('') do |memo, (name, hash)|
                 memo << "$fa-#{name.gsub(/_/, '-')}: #{hash['color']};\n"

                 if hash['contrast']
                   memo << "$fa-contrast-#{name.gsub(/_/, '-')}: #{color_by_name(hash['contrast'])};\n"
                 end

                 memo
               end

  color_map  = "$fa_colors: (\n" +
                 get_config['colors'].inject('') do |memo, (name, hash)|
                   memo << "  '#{name}': ( color: #{hash['color']}"

                   if hash['contrast']
                     memo << ", contrast_name: '#{hash['contrast']}'"
                     memo << ", contrast_color: #{color_by_name(hash['contrast'])}"
                   end

                   memo << " ),\n"
                 end +
               ");\n"

  other_vars = get_config['scss_variables'].inject('') do |memo, (key, value)|
                 "#{memo}$#{key}: '#{value}';\n"
               end

  color_vars + color_map + other_vars
end

def tools_scss_list
  Rake::FileList.new(*get_config['scss_tools_order'])
end

def copy_and_clean(name)
  puts "Copying #{name}"
  files = FileList.new("#{name}/**/*")

  cp_r files, "compiled/#{name}", verbose: false
  cleanup(name, *files.map { |path| "compiled/#{path}" })
end

class Hash
  def deep_merge!(other)
    # TODO: Use recursive call instead?
    # This was copied from terrible code on StackOverflow
    merger = proc do |key, obj1, obj2|
               if obj1.is_a?(Hash) && obj2.is_a?(Hash)
                 obj1.merge(obj2, &merger)
               elsif obj1.is_a?(Array) && obj2.is_a?(Array)
                 obj1 | obj2
               elsif [nil].include?(obj2)
                 obj1
               else
                 obj2
               end
             end

    self.merge!(other, &merger)
  end
end
