require 'rubygems'
require 'bundler/setup'
require 'nokogiri'
require 'sass'

require 'thread'
require 'io/console'
require 'yaml'
require 'pp'

ThreadCount = 8
SCSSTools   = 'compiled/scss/_falafel.scss'
STDOUT.echo = false

# Get starting time so we can calculate how long the task took.
starting_time = Time.now

# When finished, print the running time and make sure echo is turned on again.
at_exit do |success|
  print "\n"
  puts Time.at(Time.now - starting_time)
           .utc
           .strftime("Running time: \033[36m%H:%M:%S\033[0m")

  STDOUT.echo = true
end

task :default => [:init, :scss, :css, :icons, :docs]

task :init do
  puts "Initializing directories..."

  setup_directory('compiled')
  setup_directory('compiled/icon')
  setup_directory('compiled/scss')
  setup_directory('compiled/css')
end

task :scss => [:init] do
  puts "Creating scss files..."

  color_vars = get_config['colors'].inject('') do |memo, (key, value)|
                 "#{memo}$fa_#{key}: #{value};\n"
               end

  other_vars = get_config['scss_variables'].inject('') do |memo, (key, value)|
                 "#{memo}$#{key}: '#{value}';\n"
               end

  tools_scss = Rake::FileList.new(*get_config['scss_tools_order'])
                             .map { |path| File.new(path).read }

  overwrite(
    SCSSTools,
    ([color_vars, other_vars] + tools_scss).join("\n")
  )

  cleanup('compiled/scss/*', SCSSTools)
end

task :css => [:init, :scss] do
  edited = []

  get_config['scss_rules_order'].each do |name, source_paths|
    puts "Compiling #{name}.css ..."

    new_path = "compiled/css/#{name}.css"
    edited << new_path

    scss = File.read(SCSSTools) <<
           Rake::FileList.new(*source_paths)
                         .inject('') do |memo, path|
                           memo << File.new(path).read
                         end

    options = {
                syntax: :scss,
                style:  :compressed,
                cache:  false
              }

    overwrite(
      new_path,
      Sass::Engine.new(scss, options).render
    )
  end

  cleanup('compiled/css/*', edited)
end

task :icons => [:init] do
  colors  = get_config['colors']
  message = 'Rendering icons'

  start_loading_message message

  edited = threaded_map(
                         Rake::FileList.new('icons/source/**/*.svg'),
                         'edited'
                       ) do |icon_array, thread_id|

             Thread.current['edited'] = []

             icon_array.each do |source_icon_path|
               svg = Nokogiri::XML(File.new(source_icon_path))

               svg.xpath('//comment()').remove

               colors.each do |color_name, color_value|

                 # Edit each SVG to include the proper color and remove comments...

                 svg.xpath('//*[@fill] | //*[@stroke]').each do |element|
                   element['fill']   = color_value if element['fill']
                   element['stroke'] = color_value if element['stroke']
                 end

                 # Save the new SVG

                 new_file_path = 'compiled/icon/' +
                                 File.basename(source_icon_path, '.svg')
                                     .gsub(/-/, '_') +
                                 "__#{color_name}.svg"

                 if Thread.current['edited'].include?(new_file_path)
                   raise "duplicate icon at #{new_file_path}"
                 else
                   Thread.current['edited'] << new_file_path
                 end

                 if thread_id.zero?
                   loading_message(
                     message,
                     Thread.current['edited'].size.to_f /
                       (icon_array.size.to_f * colors.size.to_f)
                   )
                 end

                 File.open(new_file_path, 'w+') do |new_icon|
                   new_icon.write(svg.to_s)
                 end
               end
             end
           end

  finish_loading_message message

  cleanup('compiled/icons/*', *edited)
end

task :docs => [:init] do

end

####################
## HELPER METHODS ##
####################

# Map across an array using threads to divide the work.
def threaded_map(items, key = nil)
  items.each_slice(items.size / ThreadCount)
       .map.with_index do |item_section, thread_id|
         Thread.new { yield item_section, thread_id }
       end
       .inject([]) do |memo, thread|
         if key
           thread.join
           memo.concat(thread[key])
         else
           memo << thread
         end
       end
end

def loading_message(message, fraction)
  print "\r#{message}: \033[36m" +
        sprintf("%5.1f", [1, fraction].min * 100) +
        "%\033[0m"
end

def cleanup(path, *edited)
  puts 'Checking for old files...'

  leftovers = Rake::FileList.new(path) - edited

  if leftovers.empty?
    puts 'No old files to delete'
  else
    slice_size = 100
    message    = 'Deleting old icons'

    start_loading_message message

    leftovers.each_slice(slice_size).with_index do |section, index|
      %x( rm -r #{section.join(' ')} )

      loading_message(
        message,
        (index.to_f * slice_size.to_f) / leftovers.size.to_f
      )
    end

    finish_loading_message message
  end
end

def start_loading_message(message)
  print message + ': ...'
end

def finish_loading_message(message)
  loading_message message, 1
  print "\n"
end

def setup_directory(name)
  Dir.mkdir(name) unless Dir.exist?(name)
end

def get_config
  YAML.load(File.read('default-config.yaml'))
      .tap do |default_config|
        if File.exist? 'user-config.yaml'
          default_config.merge!(
            YAML.load(
              File.read('user-config.yaml')
            )
          )
        end
      end
end

def overwrite(path, content)
  File.open(path, 'w+') { |file| file.write(content) }
end
